# 과목개요
- [01소프트웨어설계](#01%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%84%A4%EA%B3%84)
- [02소프트웨어개발](#02%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C)
- [03데이터베이스구축](#03%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B5%AC%EC%B6%95)
- [04프로그래밍언어활용](#04%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9)
- [05정보시스템구축관리](#05%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC)

## 01소프트웨어설계
```
소프트웨어설계
├──Software Life Cycle
├──Software Engineering
├──Waterfall Model
├──Prototype Model
├──Spiral Model
├──Agile Model
├──애자일 개발 4가지 핵심 가치
├──스크럼의 개요
├──스크럼 개발 프로세스
├──XP(eXtreme Programming)
├──XP의 주요 실천 방법 (Practice)
├──현행 시스템 파악
├──데이터베이스 관리 시스템 (DBMS)
├──웹 애플리케이션 서버(WAS)
├──요구사항 정의
├──요구사항 개발 프로세스
├──요구사항 명세 기법
├──요구사항 분석의 개요
├──자료 흐름도(DFD)
├──자료 사전
├──요구사항 분석을 위한 CASE (자동화 도구)
├──HIPO
├──UML(Unified Modeling Language)의 개요
├──관계(Relationships)
├──다이어그램(Diagram)
├──스테레오 타입(Stereotype)
├──유스케이스(Use Case)  다이어그램
├──클래스(Class) 다이어그램
├──순차(Sequence) 다이어그램
├──사용자 인터페이스(UI)의 특징
├──사용자 인터페이스의 구분
├──사용자 인터페이스의 기본 원칙
├──사용자 인터페이스의 설계 지침
├──사용자 인터페이스 개발 시스템의 기능
├──UI 설계 도구
├──품질 요구사항
├──UI 요소
├──상위 설계와 하위 설계
├──소프트웨어 아키텍쳐 설계의  기본 원리
├──소프트웨어 아키텍처의 품질 속성
├──소프트웨어 아키텍처의 설계 과정
├──협약(Contract)에 의한 설계
├──파이프 - 필터 패턴 (Pipe - Filter Pattern)
├──모델 - 뷰 - 컨트롤러 패턴(Model - View - Controller Pattern)
├──기타 패턴
├──객체(Object)
├──클래스(Class)
├──캡슐화(Encapsulation)
├──상속(Inheritance)
├──다형성(Polymorphism)
├──연관성(Relationship)
├──객체지향 분석의 방법론
├──럼바우(Rumbaugh)의 분석 기법
├──객체지향 설계 원칙
├──결합도(Coupling)
├──응집도(Cohesion)
├──팬인(Fan-In) /  팬아웃(Fan-Out)
├──N-S 차트(Nassi-Schneiderman Chart)
├──공통 모듈의 개요
├──재사용(Reuse)
├──효과적인 모듈 설계 방안
├──코드(Code)의 개요
├──코드의 종류
├──디자인 패턴 (Design Pattern)의 개요
├──디자인 패턴 사용의 장·단점
├──생성 패턴 (Creational Pattern)
├──구조 패턴 (Structural Pattern) 
├──행위 패턴 (Behavioral Pattern)
├──요구사항 검증 방법
├──시스템 연계 기술
├──연계 매커니즘 구성요소
└──미들웨어(Middleware)
```

## 02소프트웨어개발
- 073 자료 구조의 분류  
- 074 선형 리스트(Linear List)  
- 075 스택(Stack)  
- 076 큐(Queue)  
- 077 방향/무방향 그래프의 최대 간선 수  
- 078 트리의 개요  
- 079 트리의 운행법  
- 080 수식의 표기법  
- 081 삽입 정렬(Insertion Sort)  
- 082 선택 정렬(Selection Sort)  
- 083 버블 정렬(Bubble Sort)  
- 084 퀵 정렬(Quick Sort)  
- 085 힙 정렬(Heap Sort)  
- 086 2-Way 합병 정렬(Merge Sort)  
- 087 이분 검색  
- 088 해싱 함수 (Hashing Function)  
- 089 DBMS(DataBase Management System; 데이터베이스 관리 시스템)  
- 090 DBMS의 장·단점  
- 091 스키마  
- 092 절차형 SQL의 테스트와 디버깅  
- 093 단위 모듈(Unit Module)의 개요  
- 094 IPC(Inter-Process Communication)  
- 095 단위 모듈 테스트의 개요  
- 096 테스트 케이스(Test Case)  
- 097 통합 개발 환경(IDE; Integrated Development Environment)  
- 098 빌드 도구  
- 099 소프트웨어 패키징의 개요  
- 100 패키징 시 고려사항  
- 101 릴리즈 노트(Release Note)의 개요  
- 102 릴리즈 노트 초기 버전 작성 시 고려사항  
- 103 디지털 저작권 관리(DRM; Digital Right Management)  
- 104 디지털 저작권 관리(DRM)의 구성 요소  
- 105 디지털 저작권 관리(DRM)의 기술 요소  
- 106 소프트웨어 설치 매뉴얼의 개요  
- 107 소프트웨어 설치 매뉴얼의 기본 사항  
- 108 소프트웨어 사용자 매뉴얼의 개요  
- 109 소프트웨어 패키징의 형상 관리  
- 110 형상 관리의 중요성  
- 111 형상 관리 기능  
- 112 소프트웨어의 버전 등록 관련 주요 기능  
- 113 공유 폴더 방식  
- 114 클라이언트/서버 방식  
- 115 분산 저장소 방식  
- 116 Subversion(서브버전, SVN)  
- 117 Git(깃)  
- 118 빌드 자동화 도구의 개요  
- 119 Jenkins  
- 120 Gradle  
- 121 애플리케이션 테스트의 개요  
- 122 애플리케이션 테스트 관련 용어  
- 123 프로그램 실행 여부에 따른 테스트  
- 124 테스트 기반(Test Bases)에 따른 테스트  
- 125 시각에 따른 테스트  
- 126 목적에 따른 테스트  
- 127 화이트박스 테스트 (White Box Test)  
- 128 화이트박스 테스트의 종류  
- 129 화이트박스 테스트의 검증 기준  
- 130 블랙박스 테스트 (Black Box Test)  
- 131 블랙박스 테스트의 종류  
- 132 개발 단계에 따른 애플리케이션 테스트  
- 133 단위 테스트(Unit Test)  
- 134 통합 테스트(Integration Test)  
- 135 시스템 테스트(System Test)  
- 136 인수 테스트 (Acceptance Test)  
- 137 하향식 통합 테스트 (Top Down Integration Test)  
- 138 상향식 통합 테스트(Bottom Up Integration Test)  
- 139 테스트 드라이버와 테스트 스텁의 차이점  
- 140 회귀 테스팅(Regression Testing)  
- 141 애플리케이션 테스트 프로세스  
- 142 테스트 케이스(Test Case)  
- 143 테스트 시나리오 (Test Scenario)  
- 144 테스트 오라클(Test Oracle)  
- 145 테스트 오라클의 종류  
- 146 테스트 자동화 도구  
- 147 테스트 하네스(Test Harness)의 구성 요소  
- 148 결함(Fault)  
- 149 애플리케이션 성능 분석  
- 150 빅오 표기법(Big-O Notation) 
- 151 순환 복잡도  
- 152 소스 코드 최적화  
- 153 소스 코드 품질 분석 도구  
- 154 EAI(Enterprise Application Integration)  
- 155 ESB (Enterprise Service Bus)  
- 156 JSON(JavaScript Object Notation)  
- 157 XML(eXtensible Markup Language)  
- 158 AJAX(Asynchronous JavaScript and XML)  
- 159 인터페이스 보안 기능 적용  
- 160 데이터 무결성 검사 도구  
- 161 인터페이스 구현 검증 도구  
- 162 APM(Application Performance Management/Monitoring)  

## 03데이터베이스구축
- 163 데이터베이스 설계 순서
- 164 개념적 설계(정보 모델링, 개념화)
- 165 논리적 설계(데이터 모델링)
- 166 물리적 설계(데이터 구조화)
- 167 데이터 모델
- 168 E-R 모델의 개요
- 169 E-R 다이어그램
- 170 관계형 데이터 모델
- 171 관계형 데이터베이스의 Relation 구조
- 172 릴레이션의 특징
- 173 키(Key)
- 174 무결성(Integrity)
- 175 관계대수의 개요
- 176 순수 관계 연산자
- 177 일반 집합 연산자
- 178 관계해석(Relational Calculus)
- 179 정규화의 개요
- 180 정규화의 목적
- 181 이행적 종속 / 함수적 종속
- 182 이상(Anomaly)의 개념 및 종류
- 183 정규화 과정
- 184 반정규화의 개요
- 185 반정규화 방법
- 186 시스템 카탈로그
- 187 트랜잭션
- 188 트랜잭션의 상태
- 189 트랜잭션의 특성
- 190 CRUD 분석
- 191 인덱스(Index)
- 192 인덱스의 종류
- 193 뷰(View)
- 194 파티션(Partition)
- 195 분산 데이터베이스 정의 및 구성 요소
- 196 분산 데이터베이스의 목표
- 197 분산 데이터베이스의 장·단점
- 198 암호화(Encryption)
- 199 접근통제 기술
- 200 강제 접근통제(MAC)의 보안 모델
- 201 DAS (Direct Attached Storage)
- 202 NAS (Network Attached Storage)
- 203 SAN (Storage Area Network)
- 204 DDL(Data Define Language, 데이터 정의어)
- 205 DML(Data Manipulation Language, 데이터 조작어)
- 206 DCL(Data Control Language, 데이터 제어어)
- 207 CREATE TABLE
- 208 ALTER TABLE
- 209 DROP
- 210 DCL(Data Control Language, 데이터 제어어)의 개요
- 211 GRANT / REVOKE
- 212 COMMIT
- 213 ROLLBACK
- 214 삽입문(INSERT INTO~)
- 215 삭제문(DELETE FROM~)
- 216 갱신문(UPDATE~ SET~)
- 217 데이터 조작문의 네 가지 유형
- 218 SELECT 1 - 일반 형식
- 219 조건 연산자 / 연산자 우선순위
- 220 하위 질의
- 221 SELECT 2 - 일반 형식
- 222 그룹 함수
- 223 집합 연산자를 이용한 통합 질의
- 224 INNER JOIN
- 225 트리거(Trigger)의 개요
- 226 DBMS 접속 기술
- 227 ORM(Object-Relational Mapping)의 개요
- 228 쿼리 성능 최적화의 개요
- 229 데이터 전환의 정의
- 230 데이터 검증
- 231 오류 데이터 정제

## 04프로그래밍언어활용
- 232핵심: 배치 프로그램
- 233핵심: C/C++의 데이터 타입 크기 및 기억 범위
- 234핵심: C언어의 구조체
- 235핵심: JAVA의 데이터 타입 크기 및 기억 범위
- 236핵심: Python의 시퀀스 자료형
- 237핵심: 변수의 개요 / 변수명 작성 규칙
- 238핵심: 가비지 콜렉터 (Garbage Collector)
- 239핵심: 산술 연산자
- 240핵심: 관계 연산자
- 241핵심: 비트 연산자
- 242핵심: 논리 연산자
- 243핵심: 대입 연산자
- 244핵심: 조건 연산자
- 245핵심: 연산자 우선순위
- 246핵심: scanf( ) 함수
- 247핵심: 서식 문자열
- 248핵심: printf( ) 함수
- 249핵심: 주요 제어문자
- 250핵심: JAVA에서의 표준 출력
- 251핵심: 단순 if문
- 252핵심: 다중 if문
- 253핵심: switch문
- 254핵심: for문
- 255핵심: while문
- 256핵심: do~while문
- 257핵심: break, continue
- 258핵심: 배열
- 259핵심: 2차원 배열
- 260핵심: 배열의 초기화
- 261핵심: 배열 형태의 문자열 변수
- 262핵심: 포인터와 포인터 변수
- 263핵심: 포인터와 배열
- 264핵심: Python의 기본 문법
- 265핵심: Python의 데이터 입·출력 함수
- 266핵심: 입력 값의 형변환(Casting)
- 267핵심: 리스트(List)
- 268핵심: 딕셔너리(Dictionary)
- 269핵심: 슬라이스(Slice)
- 270핵심: Python - if문
- 271핵심: Python - for문
- 272핵심: Python - While문
- 273핵심: Python - 클래스
- 274핵심: 클래스 없는 메소드의 사용
- 275핵심: 절차적 프로그래밍 언어의 종류
- 276핵심: 객체지향 프로그래밍 언어의 종류
- 277핵심: 스크립트 언어의 종류
- 278핵심: 선언형 프로그래밍 언어 종류
- 279핵심: 라이브러리
- 280핵심: C언어의 대표적인 표준 라이브러리
- 281핵심: JAVA의 예외 처리
- 282핵심: 운영체제의 정의 및 목적
- 283핵심: 운영체제의 구성
- 284핵심: 운영체제의 기능
- 285핵심: Windows
- 286핵심: UNIX의 개요 및 특징
- 287핵심: UNIX 시스템의 구성
- 288핵심: 파일 디스크립터 (File Descriptor)
- 289핵심: 기억장치 관리 - 배치(Placement) 전략
- 290핵심: 페이징(Paging) 기법
- 291핵심: 세그먼테이션(Segmentation) 기법
- 292핵심: 페이지 교체 알고리즘
- 293핵심: 페이지 크기
- 294핵심: Locality
- 295핵심: 워킹 셋(Working Set)
- 296핵심: 스래싱(Thrashing)
- 297핵심: 프로세스(Process)의 정의
- 298핵심: PCB
- 299핵심: 프로세스 상태 전이
- 300핵심: 프로세스 상태 전이 관련 용어
- 301핵심: 스레드(Thread)
- 302핵심: 주요 스케줄링 알고리즘
- 303핵심: UNIX / LINUX의 주요 환경 변수
- 304핵심: UNIX / LINUX 기본 명령어
- 305핵심: IP 주소(Internet Protocol Address)
- 306핵심: 서브네팅(Subnetting)
- 307핵심: IPv6(Internet Protocol version 6)
- 308핵심: IPv6의 구성
- 309핵심: OSI 참조 모델
- 310핵심: 네트워크 관련 장비
- 311핵심: 응용 계층의 주요 프로토콜
- 312핵심: 전송 계층의 주요 프로토콜
- 313핵심: 인터넷 계층의 주요 프로토콜
- 314핵심: 네트워크 액세스 계층의 주요 프로토콜

## 05정보시스템구축관리
- 315 구조적 방법론
- 316 정보공학 방법론
- 317 컴포넌트 기반 방법론
- 318 소프트웨어 재사용의 개요
- 319 소프트웨어 재사용 방법
- 320 소프트웨어 재공학의 개요
- 321 CASE의 개요
- 322 LOC(원시 코드 라인 수, source Line Of Code) 기법
- 323 수학적 산정 기법의 개요
- 324 COCOMO 모형 개요
- 325 COCOMO의 소프트웨어 개발 유형
- 326 Putnam 모형
- 327 기능 점수(FP) 모형
- 328 PERT
- 329 CPM
- 330 간트 차트
- 331 프로젝트 관리 (Project Management)
- 332 ISO/IEC 12207
- 333 CMMI (Capability Maturity Model Integration)
- 334 SPICE
- 335 소프트웨어 개발 방법론 테일러링
- 336 소프트웨어 개발 프레임워크
- 337 프레임워크의 특성
- 338 소프트웨어 정의 기술 (SDE, SDx)
- 339 네트워크 관련 신기술
- 340 네트워크(Network) 설치 구조
- 341 VLAN(Virtual Local Area Network)
- 342 LAN의 표준안
- 343 CSMA/CA(Carrier Sense Multiple Access/Collision Avoidance)
- 344 경로 제어 프로토콜(Routing Protocol)
- 345 흐름 제어(Flow Control)
- 346 SW 관련 용어
- 347 보안 관련 용어
- 348 HW 관련 신기술
- 349 Secure OS의 개요
- 350 Secure OS의 보안 기능
- 351 DB 관련 신기술
- 352 회복 (Recovery)
- 353 병행제어 (Concurrency Control)
- 354 교착상태
- 355 Secure SDLC의 개요
- 356 보안 요소
- 357 세션 하이재킹 (Session Hijacking)
- 358 입력 데이터 검증 및 표현의 보안 약점
- 359 보안 기능의 보안 약점
- 360 스택 가드 (Stack Guard)
- 361 접근 지정자 (접근 제어자)
- 362 개인키 암호화 기법
- 363 공개키 암호화 기법
- 364 양방향 알고리즘 종류
- 365 해시 (Hash)
- 366 솔트 (Salt)
- 367 DDoS 공격
- 368 네트워크 침해 공격 관련 용어
- 369 블루투스 관련 공격
- 370 정보 보안 침해 공격 관련 용어
- 371 인증 (Authentication)
- 372 관리적/물리적/기술적 보안
- 373 리눅스의 커널 로그
- 374 침입 탐지 시스템 (IDS)
- 375 VPN (Virtual Private Network)
- 376 SSH (Secure Shell)